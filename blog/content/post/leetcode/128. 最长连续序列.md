---
title: "128. 最长连续序列"
date: 2020-01-20
description: ""
draft: false
tags: ["array","while"]
categories: ["Leetcode"]
---



## 题目信息

> - 链接：[128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)
> - 来源：LeetCode
> - 难度：Hard

### 一、描述

> 只有题目理解到位，你可能进入下面一个环节，如果不熟悉场景，你可要小心了

- 我目的是训练动手和清晰思路。
- 从简单类型的题目开始。
- 提问是沟通的开始：敢于提问



给定一个整数数组，找出最长**连续**序列的长度。



Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(*n*) complexity.



这个题目我确实没看明白，

连续序列就是 1 2 3 4 是这样递增序列呀？ 

怎么还提到排序呢?  顶多连续序列变成 4 3 21 递减的

看下面例子，



**连续 不一定相邻，更不是顺序不变**



### 二、举例

> 在思路之前和实现之后都用到,基本情况，最好情况，和最坏情况3种。

~~~go
Input: [100, 4, 200, 1, 3, 2]
Output: 4

Explanation: 

The longest consecutive elements sequence is [1, 2, 3, 4]. 
Therefore its length is 4.

https://leetcode.com/problems/longest-consecutive-sequence/

func longestConsecutive(nums []int) int 


[1,2,3,4,5,6,7]

~~~



### 三、思路

> 为了形成你思路，并且把思路转换成步骤描述。请按照下面准备

- 关闭一切浏览器网页查看分析

- 关闭一切当前处理任务

- 关闭一切要学习的任务。

- 放下：太简单和太难这样预判。真实判断是什么 这是 关键

- 说出思路才能决定能否沟通下去。

  

  

#### 第一次分析： 【超时】

> 1. 有清晰思路和然后正确运行结果验证你思路。
>
> 2. 不考虑时间空间复杂度，不考虑各种技巧。对题目要求装作看不见。这个很关键
> 3. 20分钟内完成。Action

**直觉**

连续序列就是相差为1的序列

**描述**

1. 不进行排序，用map存储全部记录

2. 遍历数组，然后判断当前记录是否在map中，

    如果存在 继续+1判断下个元素。

    如果不存在，继续下一个元素

   

3.  重复步骤2

> 66 / 68 个通过测试用例 ,在45分钟内完成。

$$
时间复杂度：O(n^2)   ,

空间复杂度：O(n)
$$



#### 第二次分析： 【超时】

> 1. 本题入手突破点是什么？别指望用脑子想出来奇思妙想这是大忌---动手绘制流程。
>
> 2. 有什么通过模型吗？ 如果没有 不考虑时间空间复杂度，不考虑各种技巧。
>
> 3. 30分钟内完成。Action
>
>    

**直觉**

因为一个序列可能在 `nums` 数组的任意一个数字开始，我们可以枚举每个数字作为序列的第一个数字，搜索所有的可能性。

- 假如第I个元素是有序的



- 下一个元素从剩余n-1个元素选取（元素不重复）



**描述**

1. 遍历数组，假如当前元素是i for
2. 从整个元素中，寻找i下个元素 for
3. 如果寻找到 ，继续寻找，i的第三个元素 for
4. 重复 1 2 3。

$$
时间复杂度：O(n^3)   ,

空间复杂度：O(1) 和上面没有区别。都是继续寻找下一个元素
$$

#### 第三次分析： [set减少计算次数]

> 1. 本题入手突破点是什么？别指望用脑子想出来奇思妙想这是大忌---动手绘制流程。
>
> 2. 有什么通过模型吗？ 如果没有 不考虑时间空间复杂度，不考虑各种技巧。
>
> 3. 30分钟内完成。Action



对第一次 第二次进行分析

为了获取从i开始的最长连续序列，

| 元素     | 1    | 2       | 3       | 4       | 5       | 6       |
| -------- | ---- | ------- | ------- | ------- | ------- | ------- |
| 连续     | 6    | 5       | 4       | 3       | 2       | 1       |
| 计算次数 | 1    | 1(重复) | 1(重复) | 1(重复) | 1(重复) | 1(重复) |

每个一个点都要重复计算一次，

1 计算一次，

2计算一次，

3要计算一次，

4计算一次，

n个长度，

计算n次。

其实我一眼看出就是 1 2 3 4 5 6 7 后面的 2 3 4 5 67根本不需要计算---如何不计算呢？

有前驱的不计算了。

> 元素寻找 set。
>
> 如果数据有前驱，就不需要计算了。



描述:

1. unordered_set   存储每个元素，用来判断该元素存在不存在
2. 遍历input数组。 if 当前元素有前驱(-1)，不需要计算。
3. 如果元素有后继(+1),继续寻找。知道不存在未知
4. 重复步骤 2



### 四、实现

> 你可以实现。你可以做到

- 你按照你理解，就用最笨方法，你要写出来。其他高级技巧，我不懂，我也会。

- 不要因为不是最佳，最巧妙，最完美。不符合别人网上流程标准解法 就停止写

  通过写，来验证你步骤描述是否正确，你分析是否正确，必须去。

- 在没有写出来之前，拒绝一切总结，写文档，还有告诉别人。

  自己做不到，不清楚事情，你告诉别人，鬼才信呢！

  
  
  ### 第一次分析代码 【超时】
  
  ![image.png](https://i.loli.net/2020/01/16/T74Ffa2QoOeshHu.png)
  
  

- 测算用例 https://leetcode-cn.com/submissions/detail/43833838/testcase/ 

~~~c++

class Solution {
public:
    int longestConsecutive(vector<int>& nums) {

        int maxLength = 0;
        int flag =false;
        
        for (int i=0;i<nums.size();i++)
        {
           int currentNum = nums[i]+1;
           int currentLen =1;
           do
           {   
               flag =false; //每次元素都不相同
               for(int j=0;j<nums.size();j++)
               {
                 if(nums[j] ==currentNum)
                 {
                     flag =true;
                     break;
                 }
               }
               if (flag ==true)
               {
                    currentNum ++;
                    currentLen++;

               }
              
           } while(flag);

           maxLength =max(maxLength,currentLen);
        }

        return maxLength;
    }
};
~~~

- 第三次分析 代码

~~~c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        
       unordered_set<int> data(nums.begin(),nums.end());

       int path =0;
       int curLongestPath =0;
       int curElement =0 ;
    
       for (int i = 0; i < nums.size(); i++)
       {   
           curElement =nums[i];
           curLongestPath =0;
           if(data.count(curElement-1) >0)
           {
             continue; //减少计算次数
           }
          
          do
          {  
             curLongestPath++;
             curElement++;

          } while (data.count(curElement) ==1);

          path =max(path,curLongestPath);
          

       }
       
 return path;



    }
};
~~~





### 五、回顾

- 耗时统计 

| 步骤         | 分钟 | 备注       |
| ------------ | ---- | ---------- |
| 打开题目     | 30   | 都看什么了 |
| 分析题目     |      |            |
| **实现题目** |      |            |
| **查看答案** |      |            |

开始：2020年1月16日 09:55:14

结束：2020年1月20日 16:17:12





- 思路回顾

1.第一个疑问就是正序，和倒叙都是连续，你怎么判断？在意识中 和例子中默认都是根据从小到大判断的[你这样考虑隐藏一个bug，倒序数据超时]

2. 第二个问题，因为是无须，如何寻找下一个元素。全部遍历或者set

3. 第三个拦路虎 是1和2解决，怎么还是超时。如何 1 2 3 4 ，如果1=2-1，1计算过了，2不需要计算，2=3-1，如果fun(2),不计算fun(3)

   | 元素     | 1    | 2    | 3    | 4    | 5    | 6    |
   | -------- | ---- | ---- | ---- | ---- | ---- | ---- |
   | 连续     | 6    | 5    | 4    | 3    | 2    | 1    |
   | 计算次数 | 1    | 1    | 1    | 1    | 1    | 1    |



### 六、  举一反三

> 换个马甲就不认识了。



300.最长上升子序列

https://leetcode-cn.com/problems/longest-increasing-subsequence/

298(Binary Tree Longest Consecutive Sequence)



## 七、 塔山

https://leetcode.com/problems/longest-consecutive-sequence/discuss/41060/A-simple-C%2B%2Bsolution-using-unordered_set.And-simple-consideration-about-this-problem